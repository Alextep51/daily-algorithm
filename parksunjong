// 행렬 테두리 회전하기
class Solution {
	int[][] arr;
    public int[] solution(int rows, int columns, int[][] queries) {
        int[] answer = new int[queries.length];
        
        // 행렬 담을 배열 선언
        arr = new int[rows][columns];
        for(int i = 0; i < rows; i++) {
        	for (int j = 0; j < columns; j++) {
        		arr[i][j] = columns*i + j + 1;
        	}
        }
        
        // queries 길이만큼 반복
        for(int i = 0; i < queries.length; i++){
            answer[i] = turning(queries[i]);
        }
        
        return answer;
    }
    
    // 회전하는 부분
    public int turning(int[] query) {
    	int y1 = query[0]-1; 
        int x1 = query[1]-1;
        int y2 = query[2]-1;
        int x2 = query[3]-1;
        
        int tmp = arr[y1][x1]; 
        
        int min = tmp;
        // 맨 뒤에서부터(y축 한칸씩 올리기)
        for(int i = y1; i < y2; i++){ 
            arr[i][x1] = arr[i+1][x1];
            if(min > arr[i][x1]) {
            	min = arr[i][x1];
            }
        }
        // 밑에 X축 한칸씩 왼쪽으로
        for(int i = x1; i < x2; i++){ 
            arr[y2][i] = arr[y2][i+1];
            if(min > arr[y2][i]) {
            	min = arr[y2][i];
            }
        }
        // 오른쪽 y축 한칸씩 내리기
        for(int i = y2; i > y1; i--){
            arr[i][x2] = arr[i-1][x2];
            if(min > arr[i][x2]) {
            	min = arr[i][x2];
            }
        }
        // 맨 윗줄 x축 한칸씩 오른쪽으로
        for(int i = x2; i > x1; i--){
            arr[y1][i] = arr[y1][i-1];
            if(min > arr[y1][i]) {
            	min = arr[y1][i];
            }
        }
        // 값이 안들어간 부분 초기 tmp에 담은 값 넣어주기
        arr[y1][x1+1] = tmp;
        
        return min;
    }
}

// 
class Solution {
	// 23:59분을 분으로 변경
	final static int LASTTIME = 1439;
    public int[] solution(int[] fees, String[] records) {
        int[] answer = {};
        
        // 차량 스케쥴을 저장하고 key값 정렬을 위해 TreeMap 
        Comparator<String> comparator = (s1, s2) -> s1.compareTo(s2);
        Map<String, String> carMap = new TreeMap<>(comparator);
        
        // 기본 시간(분)
        int defaultTime = fees[0];
        // 기본 요금(원)
        int defaultFee = fees[1];
        // 단위 시간(분)
        int usingTime = fees[2];
        // 단위 요금(원)
        int usingFee = fees[3];
        
        // KEY : 자동차 번호... VALUE : 시간
        for(int i = 0; i < records.length; i++) {
        	String time = records[i].split(" ")[0];
        	String carNumber = records[i].split(" ")[1];
        	// 자동차 번호 키가 없을 경우 새로 등록
        	if(!carMap.containsKey(carNumber)) {
        		carMap.put(carNumber, time);
        	// 자동차 번호 키가 있을 경우 기존 값 업데이트
        	} else {
        		carMap.put(carNumber, carMap.get(carNumber) + "/" + time);
        	}	
        }
        
        // return 값에 carMap size 만큼 크기 선언
        answer = new int[carMap.size()];
        int count = 0;
        
        Iterator<Map.Entry<String, String>> itr = carMap.entrySet().iterator();
        // 순회해서 없을때까지 반복
        while(itr.hasNext()) {
        	Map.Entry<String, String> entry = itr.next();
        	int sum = 0;
        	// value의 길이가 짝수인 경우 == in, out 시간이 다 등록되어있음
        	if(entry.getValue().split("/").length % 2 == 0) {
        		String[] time = entry.getValue().split("/");
        		for(int i = 0; i < time.length; i+=2) {
        			int inTime = (Integer.parseInt(time[i].split(":")[0]) * 60) + Integer.parseInt(time[i].split(":")[1]);
        			int outTime = (Integer.parseInt(time[i+1].split(":")[0]) * 60) + Integer.parseInt(time[i+1].split(":")[1]);
        			sum += outTime - inTime;
        		}
        	// value의 길이가 홀수인 경우 == 마지막 출차 시간이 없음
        	} else {
        		String[] time = entry.getValue().split("/");
        		for(int i = 0; i < time.length-1; i+=2) {
        			int inTime = (Integer.parseInt(time[i].split(":")[0]) * 60) + Integer.parseInt(time[i].split(":")[1]);
        			int outTime = (Integer.parseInt(time[i+1].split(":")[0]) * 60) + Integer.parseInt(time[i+1].split(":")[1]);
        			sum += outTime - inTime;
        		}
        		sum += LASTTIME - ((Integer.parseInt(time[time.length-1].split(":")[0]) * 60) + Integer.parseInt(time[time.length-1].split(":")[1]));
        	}
        	
        	// return 값에 요금 등록
        	if(sum <= defaultTime) {
        		answer[count] = defaultFee;
        	} else {
        		if((sum - defaultTime) % usingTime == 0) {
        			answer[count] = defaultFee + ((sum-defaultTime) / usingTime) * usingFee;
        		} else {
        			answer[count] = defaultFee + ((sum-defaultTime) / usingTime + 1) * usingFee;
        		}
        	}
        	count++;
        }
        
        return answer;
    }
}
